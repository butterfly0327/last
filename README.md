# AI 사용 보고서

이 프로젝트는 음식 이미지 인식, 식단 추천/평가, 운동 평가, 맞춤형 챗봇 기능을 위해 AI를 활용합니다. 아래는 **프로젝트 코드에 구현된 AI 기능을 기준으로** 작성한 상세 분석 보고서입니다.

---

## 1. 음식 이미지 인식 (YOLOv8m 학습 모델)

### 1) AI 사용 목적
- 음식 이미지를 자동으로 분류/탐지하여 사용자가 업로드한 사진이 어떤 음식인지 빠르게 판단합니다.
- 식단 기록 자동화(음식명 추정)를 통해 사용자의 입력 부담을 줄이고 정확도를 높입니다.

### 2) 기능 분석
- **모델 로딩 및 추론**: `AI/app/main.py`에서 `ultralytics.YOLO` 모델을 로드하고, 업로드된 이미지를 추론합니다.
- **클래스 매핑**: `models/classes.yaml`를 읽어 클래스 ID를 음식명으로 매핑합니다. (없으면 숫자 라벨 반환)
- **API 제공**: `/api/v1/detect` 엔드포인트에서 이미지 파일을 받아 예측 결과(`label`, `confidence`, `bounding box`)를 반환합니다.
- **임계값**: `confidence_threshold`(기본 0.25) 이상만 결과로 제공합니다.

### 3) 장점
- 대량의 음식 이미지를 자동 분류하여 **식단 기록 효율**이 크게 향상됩니다.
- 이미지 기반 입력으로 사용자 편의성이 높아지고, 수기 입력 오류를 줄입니다.
- 클래스 맵을 별도 YAML로 관리하여 **음식 라벨 확장/교체가 용이**합니다.

### 4) 사용된 주요 프롬프트
- **해당 기능은 텍스트 프롬프트를 사용하지 않습니다.**
  - YOLO는 이미지 기반 객체 탐지 모델이며, 코드상 프롬프트 문자열을 전달하지 않습니다.

### 5) AI 관련 모델 및 알고리즘 설명
- **모델**: YOLOv8m (Ultralytics)
- **학습 데이터**: 100가지 음식 × 음식별 700장
- **평가 지표**
  - mAP50-95: **0.8972**
  - mAP50: **0.9408**
  - mAP75: **0.9080**
- **지표 설명 및 해석**
  - **mAP50-95 (COCO mAP)**: IoU 0.50부터 0.95까지 0.05 간격으로 평균한 정밀도(AP)의 평균입니다. 모델이 다양한 IoU 기준에서 얼마나 안정적으로 탐지하는지를 보여주는 **가장 엄격한 지표**입니다.
    - **0.8972는 매우 높은 수준**이며, 다양한 IoU 기준에서도 탐지 성능이 일관적임을 의미합니다.
  - **mAP50**: IoU 0.50 기준에서의 mAP입니다. **탐지 박스가 대략적으로 맞기만 해도 정답으로 인정**되므로 상대적으로 관대한 기준입니다.
    - **0.9408은 매우 우수**하며, 음식 객체를 잘 찾아내는 높은 탐지 성능을 의미합니다.
  - **mAP75**: IoU 0.75 기준의 mAP으로, **박스 정밀도가 상당히 높아야** 정답으로 인정됩니다.
    - **0.9080은 높은 정밀도**를 보여주며, 음식 영역을 정확하게 잡는 능력이 뛰어남을 나타냅니다.
- **특징**: 단일 네트워크로 객체 탐지 및 분류를 동시에 수행하는 실시간 탐지 모델.

### 6) 프로젝트에서 AI 사용의 한계
- 모델이 학습하지 않은 음식에 대해 일반화가 어려울 수 있습니다.
- 촬영 환경(조명, 각도, 가림) 변화에 의해 정확도 저하가 발생할 수 있습니다.
- **단일 모델** 기반이므로 식당 메뉴/가공식품 등 복잡한 음식군에 대한 세밀한 분류 한계가 있습니다.

### 7) 미래 계획 및 개선 방향
- 음식 카테고리 확장(더 많은 음식 클래스 추가)
- 모델 앙상블 또는 세분화된 서브모델(한식/양식/디저트 등) 도입
- 사용자 피드백 기반의 **지속 학습(Active Learning)** 파이프라인 구축

---

## 2. AI를 이용한 식단 추천 (Gemini)

### 1) AI 사용 목적
- 사용자의 건강 정보 및 최근 섭취 기록을 고려하여 하루 식단(아침/점심/저녁)을 추천합니다.
- 사용자의 목표(체중 감량/유지 등)에 맞는 맞춤형 식단을 제안합니다.

### 2) 기능 분석
- `AiRecommendationService.generateMealPlan()`에서 Gemini 모델을 호출합니다.
- **입력 데이터**: 사용자 건강 정보, 주간 식단 통계, 목표 날짜
- **출력 형식**: JSON만 반환하도록 강제하며, 아침/점심/저녁 메뉴와 칼로리를 포함합니다.
- 응답 파싱 후 DB에 저장(`prompt_context`, `raw_response` 포함)

### 3) 장점
- 데이터 기반 맞춤형 식단 추천 → **개인화된 식단 설계** 가능
- JSON 포맷 강제 → UI/프론트 연동이 용이하고 자동화에 적합
- 사용자 상황(질환, 활동량, 최근 섭취량)을 반영하여 현실적인 제안 가능

### 4) 사용된 주요 프롬프트 (코드 그대로)
`AiRecommendationService.buildMealPrompt()`에서 사용:

```
다음 정보를 바탕으로 한국어 JSON만 반환해 주세요.
출력 포맷: {"breakfast":{"menu":...,"calories":숫자,"comment":...}, "lunch":{...}, "dinner":{...}, "totalCalories":숫자}
각 menu는 음식과 곁들이는 재료를 3~5개 bullet 없이 콤마로 나열하고, comment는 한 줄 평가입니다.
목표 날짜: {targetDate} (요일: {dayName})
사용자 건강 정보: 키 {height}cm, 현재체중 {weight}kg, 목표체중 {goalWeight}kg, 활동수준 {activityLevel}, 당뇨:{diabetes}, 고혈압:{hypertension}, 고지혈증:{hyperlipidemia}, 기타:{otherDisease}, 목표:{goal}
이번 주 월요일부터 현재까지 섭취 요약:
{날짜/영양소 요약 리스트}
요청: 1) 아침/점심/저녁별 메뉴 제안 2) 각 끼니 칼로리 숫자만 3) 각 끼니 한 줄 comment 4) totalCalories 합산 숫자. 추가 설명이나 문장은 쓰지 말 것.
```

### 5) AI 관련 모델 및 알고리즘 설명
- **모델**: Gemini 2.5 Flash (`gemini-2.5-flash:generateContent`)
- **특징**: 빠른 응답과 요약/추천에 최적화된 경량 모델 계열
- **인터페이스**: REST API 호출 방식으로 프롬프트 기반 응답 생성

### 6) 프로젝트에서 AI 사용의 한계
- 음식 영양/칼로리를 정확히 계산하기보다 **언어 모델의 추정**에 의존함
- JSON 포맷에 엄격하나, 모델이 규격을 벗어난 응답을 반환할 가능성 존재
- 개인 건강 정보가 충분히 상세하지 않으면 맞춤형 정확도 한계

### 7) 미래 계획 및 개선 방향
- 추천 결과에 **영양 DB 기반 검증/보정 로직** 추가
- 사용자 알레르기/기호/예산 정보 반영
- UI 상에서 추천 이유(근거)를 함께 제공해 투명성 향상

---

## 3. AI를 이용한 주간 식단 평가 (Gemini)

### 1) AI 사용 목적
- 사용자의 주간 섭취 데이터를 바탕으로 **영양 균형 상태(탄수/단백/지방/칼로리)**를 평가합니다.
- 건강 목표 대비 부족/적정/과다 여부를 요약합니다.

### 2) 기능 분석
- `AiRecommendationService.generateNutritionReview()`에서 Gemini 호출
- **입력 데이터**: 사용자 건강 정보 + 주간 식단 통계
- **출력 형식**: JSON으로 `carbohydrateStatus`, `proteinStatus`, `fatStatus`, `calorieStatus`, `summaryText` 반환
- 결과는 DB에 저장되어 추후 조회 가능

### 3) 장점
- 주간 단위로 영양 균형을 자동 분석하여 사용자에게 피드백 제공
- 식단을 질적(문장) + 정량적(LOW/ADEQUATE/HIGH)으로 제공
- 사용자 피드백 루프 형성 → 꾸준한 식단 관리 유도

### 4) 사용된 주요 프롬프트 (코드 그대로)
`AiRecommendationService.buildNutritionPrompt()`에서 사용:

```
주어진 데이터로 영양 평가를 JSON으로만 작성하세요.
포맷: {"carbohydrateStatus":"LOW|ADEQUATE|HIGH", "proteinStatus":..., "fatStatus":..., "calorieStatus":..., "summaryText":"문장"}
평가 기준: 주 전체는 7일, 현재 주는 {dayOfWeek}일차까지 진행됨. 현재 시간 {now} 기준으로 아침(08:00), 점심(14:00), 저녁(20:00) 지나지 않은 끼니는 앞으로 먹을 수 있음을 반영.
건강 정보: 키{height}cm, 몸무게{weight}kg, 목표{goalWeight}kg, 질환:{diabetes}/{hypertension}/{hyperlipidemia}
섭취 데이터:
{날짜/영양소 요약 리스트}
요청: 각 status는 LOW/ ADEQUATE/ HIGH 중 하나로, summaryText는 2~3문장으로 개선 방향을 포함. 여분 텍스트 금지.
```

### 5) AI 관련 모델 및 알고리즘 설명
- **모델**: Gemini 2.5 Flash
- **특징**: 빠른 텍스트 생성, 요약 및 평가 메시지 생성에 유리

### 6) 프로젝트에서 AI 사용의 한계
- 영양소 기준치(권장량)를 엄격히 반영하는 규칙 기반 평가가 아님
- 섭취 데이터가 누락되면 평가의 신뢰도가 저하
- 요약 텍스트가 주관적일 수 있어 사용자 신뢰 확보 필요

### 7) 미래 계획 및 개선 방향
- WHO/국가 영양 권장량 기준을 적용한 **정량 평가 로직** 병행
- 실제 섭취량과 비교한 시각화 대시보드 제공
- 사용자 목표(근성장/감량 등)별 평가 기준 분리

---

## 4. AI를 이용한 주간 운동 평가 (Gemini)

### 1) AI 사용 목적
- 사용자의 주간 운동 기록을 분석해 운동량이 부족/적정/과다인지 평가합니다.
- 목표 체중 대비 맞춤형 운동 추천을 제공합니다.

### 2) 기능 분석
- `AiRecommendationService.generateExerciseReview()`에서 Gemini 호출
- **입력 데이터**: 사용자 건강 정보 + 주간 운동 기록
- **출력 형식**: JSON (`volumeStatus`, `recommendation`, `summaryText`)

### 3) 장점
- 주간 운동 데이터 기반 자동 피드백 → 운동 지속성 증가
- 사용자 상태를 반영한 맞춤형 운동 제안 가능
- 기록 기반으로 과다/부족 경고 제공

### 4) 사용된 주요 프롬프트 (코드 그대로)
`AiRecommendationService.buildExercisePrompt()`에서 사용:

```
주간 운동 데이터를 평가하고 JSON만 반환하세요.
포맷: {"volumeStatus":"LOW|ADEQUATE|HIGH", "recommendation":"간단 추천", "summaryText":"문장"}
현재 주 진행일: {dayOfWeek}일차 (월요일 시작).
몸무게 목표: 현재 {weight}kg -> 목표 {goalWeight}kg. 활동수준 {activityLevel}.
운동 기록:
{날짜/운동시간/칼로리 요약 리스트}
요청: volumeStatus는 LOW/ ADEQUATE/ HIGH 중 하나, recommendation은 1~2문장 운동 제안, summaryText는 2문장으로 평가. 여분 텍스트 금지.
```

### 5) AI 관련 모델 및 알고리즘 설명
- **모델**: Gemini 2.5 Flash
- **특징**: 짧은 평가/추천 생성에 적합한 경량 생성 모델

### 6) 프로젝트에서 AI 사용의 한계
- 운동 유형(유산소/근력/유연성)을 구분한 세밀 평가 미흡
- 추천 운동이 사용자 건강 상태(부상 등)를 충분히 반영하지 못할 수 있음
- 정량적 기준 없이 텍스트 기반 평가에 의존

### 7) 미래 계획 및 개선 방향
- 운동 종류별 세부 평가(근력/유산소/스트레칭 분리)
- 사용자 운동 목표(체중 감량/근력 향상)별 가중치 반영
- 웨어러블 데이터와 연동해 심박수/운동 강도 기반 평가 강화

---

## 5. AI 챗봇 기능 (사용자 맞춤형 Gemini 대화)

### 1) AI 사용 목적
- 사용자의 건강/식단/운동 정보를 활용해 맞춤형 대화형 상담을 제공합니다.
- 이전 대화 히스토리를 유지하여 연속적인 대화 경험을 제공합니다.

### 2) 기능 분석
- `AiChatbotService.processJob()`에서 Gemini 호출
- **입력 데이터**
  - 사용자 건강 정보
  - 주간 식단/운동 요약
  - 이전 대화 히스토리
  - 사용자 질문
- **출력**: 모델이 작성한 답변을 DB에 저장하여 대화 흐름 유지

### 3) 장점
- 개인화된 건강 상담 제공 → 사용자 만족도 향상
- 대화 맥락을 유지하여 자연스러운 코치 경험 제공
- 식단/운동/건강 질문을 한 번에 처리 가능

### 4) 사용된 주요 프롬프트 (코드 그대로)
`AiChatbotService.buildPrompt()`에서 사용:

```
당신은 사용자 맞춤형 건강/영양/운동 코치입니다. 제공된 데이터만 활용해 정확하고 근거 있는 답변을 주세요.
[응답 원칙]
- 반드시 한국어 존댓말을 사용하고, 따뜻하고 명확하게 안내합니다.
- 불확실한 내용은 가정이나 전제를 명시하고 단정하지 않습니다.
- 답변은 핵심만 간결하게 5문장 또는 800자 이내로 작성합니다.

[오늘 정보]
- 날짜: {today}
- 요일: {dayOfWeek}

[사용자 건강 정보]
- 키: {height} cm
- 현재 체중: {weight} kg
- 목표 체중: {goalWeight} kg
- 당뇨: {diabetes}
- 고혈압: {hypertension}
- 고지혈증: {hyperlipidemia}
- 기타 질환: {otherDisease}
- 활동 수준: {activityLevel}

[주간 식단 요약]
{dietStats}

[주간 운동 요약]
{exerciseStats}

[이전 대화 히스토리]
{conversationHistory}

[사용자 질문]
{question}
```

### 5) AI 관련 모델 및 알고리즘 설명
- **모델**: Gemini 2.5 Flash
- **특징**: 대화형 문장 생성 및 요약에 최적화된 멀티턴 텍스트 생성

### 6) 프로젝트에서 AI 사용의 한계
- 모델이 제공된 데이터 외의 건강 정보를 **추정**할 위험 존재
- 의료적 조언의 정확성과 책임 문제 → 반드시 제한 문구 필요
- 대화 길이가 길어질수록 비용/응답 지연 가능성 증가

### 7) 미래 계획 및 개선 방향
- 전문 영양/운동 가이드라인을 시스템 프롬프트에 추가
- 사용자 선호(톤, 목표, 알레르기)를 기억하는 장기 메모리 기능
- 의료 상담이 아닌 범위를 명확히 하는 안전 필터 강화

---

## 전체 결론
- 본 프로젝트는 **컴퓨터 비전 기반 음식 인식(YOLOv8m)**과 **생성형 AI(Gemini)**를 결합하여, 식단·영양·운동 전반을 자동화하고 개인화합니다.
- 데이터 기반 추천/평가/대화형 상담을 통해 사용자 경험을 강화하고, 기록 효율성을 높입니다.
- 향후 **정량 기준 강화, 사용자 선호/의료 안전성 확보, 데이터 확장**을 통해 AI 기능의 신뢰성과 활용도를 더욱 높일 수 있습니다.
